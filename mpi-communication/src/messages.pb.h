// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class CommonFile;
class Task;
class Task_InputFile;
class Task_OutputFile;
class Task_Variable;
class Task_Environment;
class Task_Command;
class TaskResult;
class TaskResult_OutputFile;

enum Task_InputFile_PreProcessor {
  Task_InputFile_PreProcessor_NONE = 1,
  Task_InputFile_PreProcessor_ARCHIVE_UNZIP = 2,
  Task_InputFile_PreProcessor_FILE_GUNZIP = 3
};
bool Task_InputFile_PreProcessor_IsValid(int value);
const Task_InputFile_PreProcessor Task_InputFile_PreProcessor_PreProcessor_MIN = Task_InputFile_PreProcessor_NONE;
const Task_InputFile_PreProcessor Task_InputFile_PreProcessor_PreProcessor_MAX = Task_InputFile_PreProcessor_FILE_GUNZIP;
const int Task_InputFile_PreProcessor_PreProcessor_ARRAYSIZE = Task_InputFile_PreProcessor_PreProcessor_MAX + 1;

const ::google::protobuf::EnumDescriptor* Task_InputFile_PreProcessor_descriptor();
inline const ::std::string& Task_InputFile_PreProcessor_Name(Task_InputFile_PreProcessor value) {
  return ::google::protobuf::internal::NameOfEnum(
    Task_InputFile_PreProcessor_descriptor(), value);
}
inline bool Task_InputFile_PreProcessor_Parse(
    const ::std::string& name, Task_InputFile_PreProcessor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Task_InputFile_PreProcessor>(
    Task_InputFile_PreProcessor_descriptor(), name, value);
}
enum Task_InputFile_Scope {
  Task_InputFile_Scope_RUN = 1,
  Task_InputFile_Scope_JOB = 2,
  Task_InputFile_Scope_TASK = 3
};
bool Task_InputFile_Scope_IsValid(int value);
const Task_InputFile_Scope Task_InputFile_Scope_Scope_MIN = Task_InputFile_Scope_RUN;
const Task_InputFile_Scope Task_InputFile_Scope_Scope_MAX = Task_InputFile_Scope_TASK;
const int Task_InputFile_Scope_Scope_ARRAYSIZE = Task_InputFile_Scope_Scope_MAX + 1;

const ::google::protobuf::EnumDescriptor* Task_InputFile_Scope_descriptor();
inline const ::std::string& Task_InputFile_Scope_Name(Task_InputFile_Scope value) {
  return ::google::protobuf::internal::NameOfEnum(
    Task_InputFile_Scope_descriptor(), value);
}
inline bool Task_InputFile_Scope_Parse(
    const ::std::string& name, Task_InputFile_Scope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Task_InputFile_Scope>(
    Task_InputFile_Scope_descriptor(), name, value);
}
enum Task_OutputFile_PostProcessor {
  Task_OutputFile_PostProcessor_NONE = 1,
  Task_OutputFile_PostProcessor_FILE_GZIP = 2
};
bool Task_OutputFile_PostProcessor_IsValid(int value);
const Task_OutputFile_PostProcessor Task_OutputFile_PostProcessor_PostProcessor_MIN = Task_OutputFile_PostProcessor_NONE;
const Task_OutputFile_PostProcessor Task_OutputFile_PostProcessor_PostProcessor_MAX = Task_OutputFile_PostProcessor_FILE_GZIP;
const int Task_OutputFile_PostProcessor_PostProcessor_ARRAYSIZE = Task_OutputFile_PostProcessor_PostProcessor_MAX + 1;

const ::google::protobuf::EnumDescriptor* Task_OutputFile_PostProcessor_descriptor();
inline const ::std::string& Task_OutputFile_PostProcessor_Name(Task_OutputFile_PostProcessor value) {
  return ::google::protobuf::internal::NameOfEnum(
    Task_OutputFile_PostProcessor_descriptor(), value);
}
inline bool Task_OutputFile_PostProcessor_Parse(
    const ::std::string& name, Task_OutputFile_PostProcessor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Task_OutputFile_PostProcessor>(
    Task_OutputFile_PostProcessor_descriptor(), name, value);
}
// ===================================================================

class CommonFile : public ::google::protobuf::Message {
 public:
  CommonFile();
  virtual ~CommonFile();

  CommonFile(const CommonFile& from);

  inline CommonFile& operator=(const CommonFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonFile& default_instance();

  void Swap(CommonFile* other);

  // implements Message ----------------------------------------------

  CommonFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonFile& from);
  void MergeFrom(const CommonFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 chunk = 2;
  inline bool has_chunk() const;
  inline void clear_chunk();
  static const int kChunkFieldNumber = 2;
  inline ::google::protobuf::int32 chunk() const;
  inline void set_chunk(::google::protobuf::int32 value);

  // required bool last = 3;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 3;
  inline bool last() const;
  inline void set_last(bool value);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:messages.CommonFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_chunk();
  inline void clear_has_chunk();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 chunk_;
  bool last_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static CommonFile* default_instance_;
};
// -------------------------------------------------------------------

class Task_InputFile : public ::google::protobuf::Message {
 public:
  Task_InputFile();
  virtual ~Task_InputFile();

  Task_InputFile(const Task_InputFile& from);

  inline Task_InputFile& operator=(const Task_InputFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task_InputFile& default_instance();

  void Swap(Task_InputFile* other);

  // implements Message ----------------------------------------------

  Task_InputFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task_InputFile& from);
  void MergeFrom(const Task_InputFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Task_InputFile_PreProcessor PreProcessor;
  static const PreProcessor NONE = Task_InputFile_PreProcessor_NONE;
  static const PreProcessor ARCHIVE_UNZIP = Task_InputFile_PreProcessor_ARCHIVE_UNZIP;
  static const PreProcessor FILE_GUNZIP = Task_InputFile_PreProcessor_FILE_GUNZIP;
  static inline bool PreProcessor_IsValid(int value) {
    return Task_InputFile_PreProcessor_IsValid(value);
  }
  static const PreProcessor PreProcessor_MIN =
    Task_InputFile_PreProcessor_PreProcessor_MIN;
  static const PreProcessor PreProcessor_MAX =
    Task_InputFile_PreProcessor_PreProcessor_MAX;
  static const int PreProcessor_ARRAYSIZE =
    Task_InputFile_PreProcessor_PreProcessor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PreProcessor_descriptor() {
    return Task_InputFile_PreProcessor_descriptor();
  }
  static inline const ::std::string& PreProcessor_Name(PreProcessor value) {
    return Task_InputFile_PreProcessor_Name(value);
  }
  static inline bool PreProcessor_Parse(const ::std::string& name,
      PreProcessor* value) {
    return Task_InputFile_PreProcessor_Parse(name, value);
  }

  typedef Task_InputFile_Scope Scope;
  static const Scope RUN = Task_InputFile_Scope_RUN;
  static const Scope JOB = Task_InputFile_Scope_JOB;
  static const Scope TASK = Task_InputFile_Scope_TASK;
  static inline bool Scope_IsValid(int value) {
    return Task_InputFile_Scope_IsValid(value);
  }
  static const Scope Scope_MIN =
    Task_InputFile_Scope_Scope_MIN;
  static const Scope Scope_MAX =
    Task_InputFile_Scope_Scope_MAX;
  static const int Scope_ARRAYSIZE =
    Task_InputFile_Scope_Scope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Scope_descriptor() {
    return Task_InputFile_Scope_descriptor();
  }
  static inline const ::std::string& Scope_Name(Scope value) {
    return Task_InputFile_Scope_Name(value);
  }
  static inline bool Scope_Parse(const ::std::string& name,
      Scope* value) {
    return Task_InputFile_Scope_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .messages.Task.InputFile.Scope scope = 2;
  inline bool has_scope() const;
  inline void clear_scope();
  static const int kScopeFieldNumber = 2;
  inline ::messages::Task_InputFile_Scope scope() const;
  inline void set_scope(::messages::Task_InputFile_Scope value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // required .messages.Task.InputFile.PreProcessor preProcessor = 4;
  inline bool has_preprocessor() const;
  inline void clear_preprocessor();
  static const int kPreProcessorFieldNumber = 4;
  inline ::messages::Task_InputFile_PreProcessor preprocessor() const;
  inline void set_preprocessor(::messages::Task_InputFile_PreProcessor value);

  // @@protoc_insertion_point(class_scope:messages.Task.InputFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_scope();
  inline void clear_has_scope();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_preprocessor();
  inline void clear_has_preprocessor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* data_;
  int scope_;
  int preprocessor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Task_InputFile* default_instance_;
};
// -------------------------------------------------------------------

class Task_OutputFile : public ::google::protobuf::Message {
 public:
  Task_OutputFile();
  virtual ~Task_OutputFile();

  Task_OutputFile(const Task_OutputFile& from);

  inline Task_OutputFile& operator=(const Task_OutputFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task_OutputFile& default_instance();

  void Swap(Task_OutputFile* other);

  // implements Message ----------------------------------------------

  Task_OutputFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task_OutputFile& from);
  void MergeFrom(const Task_OutputFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Task_OutputFile_PostProcessor PostProcessor;
  static const PostProcessor NONE = Task_OutputFile_PostProcessor_NONE;
  static const PostProcessor FILE_GZIP = Task_OutputFile_PostProcessor_FILE_GZIP;
  static inline bool PostProcessor_IsValid(int value) {
    return Task_OutputFile_PostProcessor_IsValid(value);
  }
  static const PostProcessor PostProcessor_MIN =
    Task_OutputFile_PostProcessor_PostProcessor_MIN;
  static const PostProcessor PostProcessor_MAX =
    Task_OutputFile_PostProcessor_PostProcessor_MAX;
  static const int PostProcessor_ARRAYSIZE =
    Task_OutputFile_PostProcessor_PostProcessor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PostProcessor_descriptor() {
    return Task_OutputFile_PostProcessor_descriptor();
  }
  static inline const ::std::string& PostProcessor_Name(PostProcessor value) {
    return Task_OutputFile_PostProcessor_Name(value);
  }
  static inline bool PostProcessor_Parse(const ::std::string& name,
      PostProcessor* value) {
    return Task_OutputFile_PostProcessor_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .messages.Task.OutputFile.PostProcessor postProcessor = 2;
  inline bool has_postprocessor() const;
  inline void clear_postprocessor();
  static const int kPostProcessorFieldNumber = 2;
  inline ::messages::Task_OutputFile_PostProcessor postprocessor() const;
  inline void set_postprocessor(::messages::Task_OutputFile_PostProcessor value);

  // @@protoc_insertion_point(class_scope:messages.Task.OutputFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_postprocessor();
  inline void clear_has_postprocessor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int postprocessor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Task_OutputFile* default_instance_;
};
// -------------------------------------------------------------------

class Task_Variable : public ::google::protobuf::Message {
 public:
  Task_Variable();
  virtual ~Task_Variable();

  Task_Variable(const Task_Variable& from);

  inline Task_Variable& operator=(const Task_Variable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task_Variable& default_instance();

  void Swap(Task_Variable* other);

  // implements Message ----------------------------------------------

  Task_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task_Variable& from);
  void MergeFrom(const Task_Variable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:messages.Task.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Task_Variable* default_instance_;
};
// -------------------------------------------------------------------

class Task_Environment : public ::google::protobuf::Message {
 public:
  Task_Environment();
  virtual ~Task_Environment();

  Task_Environment(const Task_Environment& from);

  inline Task_Environment& operator=(const Task_Environment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task_Environment& default_instance();

  void Swap(Task_Environment* other);

  // implements Message ----------------------------------------------

  Task_Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task_Environment& from);
  void MergeFrom(const Task_Environment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .messages.Task.Variable variable = 1;
  inline int variable_size() const;
  inline void clear_variable();
  static const int kVariableFieldNumber = 1;
  inline const ::messages::Task_Variable& variable(int index) const;
  inline ::messages::Task_Variable* mutable_variable(int index);
  inline ::messages::Task_Variable* add_variable();
  inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_Variable >&
      variable() const;
  inline ::google::protobuf::RepeatedPtrField< ::messages::Task_Variable >*
      mutable_variable();

  // @@protoc_insertion_point(class_scope:messages.Task.Environment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::messages::Task_Variable > variable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Task_Environment* default_instance_;
};
// -------------------------------------------------------------------

class Task_Command : public ::google::protobuf::Message {
 public:
  Task_Command();
  virtual ~Task_Command();

  Task_Command(const Task_Command& from);

  inline Task_Command& operator=(const Task_Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task_Command& default_instance();

  void Swap(Task_Command* other);

  // implements Message ----------------------------------------------

  Task_Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task_Command& from);
  void MergeFrom(const Task_Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string program = 1;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 1;
  inline const ::std::string& program() const;
  inline void set_program(const ::std::string& value);
  inline void set_program(const char* value);
  inline void set_program(const char* value, size_t size);
  inline ::std::string* mutable_program();
  inline ::std::string* release_program();
  inline void set_allocated_program(::std::string* program);

  // repeated string argument = 2;
  inline int argument_size() const;
  inline void clear_argument();
  static const int kArgumentFieldNumber = 2;
  inline const ::std::string& argument(int index) const;
  inline ::std::string* mutable_argument(int index);
  inline void set_argument(int index, const ::std::string& value);
  inline void set_argument(int index, const char* value);
  inline void set_argument(int index, const char* value, size_t size);
  inline ::std::string* add_argument();
  inline void add_argument(const ::std::string& value);
  inline void add_argument(const char* value);
  inline void add_argument(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_argument();

  // optional int32 timeout = 3;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:messages.Task.Command)
 private:
  inline void set_has_program();
  inline void clear_has_program();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* program_;
  ::google::protobuf::RepeatedPtrField< ::std::string> argument_;
  ::google::protobuf::int32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Task_Command* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Task_InputFile InputFile;
  typedef Task_OutputFile OutputFile;
  typedef Task_Variable Variable;
  typedef Task_Environment Environment;
  typedef Task_Command Command;

  // accessors -------------------------------------------------------

  // required int32 jobId = 1;
  inline bool has_jobid() const;
  inline void clear_jobid();
  static const int kJobIdFieldNumber = 1;
  inline ::google::protobuf::int32 jobid() const;
  inline void set_jobid(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required .messages.Task.Environment env = 3;
  inline bool has_env() const;
  inline void clear_env();
  static const int kEnvFieldNumber = 3;
  inline const ::messages::Task_Environment& env() const;
  inline ::messages::Task_Environment* mutable_env();
  inline ::messages::Task_Environment* release_env();
  inline void set_allocated_env(::messages::Task_Environment* env);

  // required string cmdId = 4;
  inline bool has_cmdid() const;
  inline void clear_cmdid();
  static const int kCmdIdFieldNumber = 4;
  inline const ::std::string& cmdid() const;
  inline void set_cmdid(const ::std::string& value);
  inline void set_cmdid(const char* value);
  inline void set_cmdid(const char* value, size_t size);
  inline ::std::string* mutable_cmdid();
  inline ::std::string* release_cmdid();
  inline void set_allocated_cmdid(::std::string* cmdid);

  // repeated .messages.Task.Command command = 5;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 5;
  inline const ::messages::Task_Command& command(int index) const;
  inline ::messages::Task_Command* mutable_command(int index);
  inline ::messages::Task_Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::messages::Task_Command >*
      mutable_command();

  // repeated .messages.Task.InputFile inputFile = 6;
  inline int inputfile_size() const;
  inline void clear_inputfile();
  static const int kInputFileFieldNumber = 6;
  inline const ::messages::Task_InputFile& inputfile(int index) const;
  inline ::messages::Task_InputFile* mutable_inputfile(int index);
  inline ::messages::Task_InputFile* add_inputfile();
  inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_InputFile >&
      inputfile() const;
  inline ::google::protobuf::RepeatedPtrField< ::messages::Task_InputFile >*
      mutable_inputfile();

  // repeated .messages.Task.OutputFile outputFile = 7;
  inline int outputfile_size() const;
  inline void clear_outputfile();
  static const int kOutputFileFieldNumber = 7;
  inline const ::messages::Task_OutputFile& outputfile(int index) const;
  inline ::messages::Task_OutputFile* mutable_outputfile(int index);
  inline ::messages::Task_OutputFile* add_outputfile();
  inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_OutputFile >&
      outputfile() const;
  inline ::google::protobuf::RepeatedPtrField< ::messages::Task_OutputFile >*
      mutable_outputfile();

  // required bool initJob = 8;
  inline bool has_initjob() const;
  inline void clear_initjob();
  static const int kInitJobFieldNumber = 8;
  inline bool initjob() const;
  inline void set_initjob(bool value);

  // repeated int32 completedJobId = 9;
  inline int completedjobid_size() const;
  inline void clear_completedjobid();
  static const int kCompletedJobIdFieldNumber = 9;
  inline ::google::protobuf::int32 completedjobid(int index) const;
  inline void set_completedjobid(int index, ::google::protobuf::int32 value);
  inline void add_completedjobid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      completedjobid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_completedjobid();

  // @@protoc_insertion_point(class_scope:messages.Task)
 private:
  inline void set_has_jobid();
  inline void clear_has_jobid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_env();
  inline void clear_has_env();
  inline void set_has_cmdid();
  inline void clear_has_cmdid();
  inline void set_has_initjob();
  inline void clear_has_initjob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 jobid_;
  ::google::protobuf::int32 index_;
  ::messages::Task_Environment* env_;
  ::std::string* cmdid_;
  ::google::protobuf::RepeatedPtrField< ::messages::Task_Command > command_;
  ::google::protobuf::RepeatedPtrField< ::messages::Task_InputFile > inputfile_;
  ::google::protobuf::RepeatedPtrField< ::messages::Task_OutputFile > outputfile_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > completedjobid_;
  bool initjob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class TaskResult_OutputFile : public ::google::protobuf::Message {
 public:
  TaskResult_OutputFile();
  virtual ~TaskResult_OutputFile();

  TaskResult_OutputFile(const TaskResult_OutputFile& from);

  inline TaskResult_OutputFile& operator=(const TaskResult_OutputFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskResult_OutputFile& default_instance();

  void Swap(TaskResult_OutputFile* other);

  // implements Message ----------------------------------------------

  TaskResult_OutputFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskResult_OutputFile& from);
  void MergeFrom(const TaskResult_OutputFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:messages.TaskResult.OutputFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TaskResult_OutputFile* default_instance_;
};
// -------------------------------------------------------------------

class TaskResult : public ::google::protobuf::Message {
 public:
  TaskResult();
  virtual ~TaskResult();

  TaskResult(const TaskResult& from);

  inline TaskResult& operator=(const TaskResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskResult& default_instance();

  void Swap(TaskResult* other);

  // implements Message ----------------------------------------------

  TaskResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskResult& from);
  void MergeFrom(const TaskResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TaskResult_OutputFile OutputFile;

  // accessors -------------------------------------------------------

  // required int32 exitCode = 1;
  inline bool has_exitcode() const;
  inline void clear_exitcode();
  static const int kExitCodeFieldNumber = 1;
  inline ::google::protobuf::int32 exitcode() const;
  inline void set_exitcode(::google::protobuf::int32 value);

  // required int64 taskDuration = 2;
  inline bool has_taskduration() const;
  inline void clear_taskduration();
  static const int kTaskDurationFieldNumber = 2;
  inline ::google::protobuf::int64 taskduration() const;
  inline void set_taskduration(::google::protobuf::int64 value);

  // repeated int64 commandDuration = 3;
  inline int commandduration_size() const;
  inline void clear_commandduration();
  static const int kCommandDurationFieldNumber = 3;
  inline ::google::protobuf::int64 commandduration(int index) const;
  inline void set_commandduration(int index, ::google::protobuf::int64 value);
  inline void add_commandduration(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      commandduration() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_commandduration();

  // required int64 workingDataSize = 4;
  inline bool has_workingdatasize() const;
  inline void clear_workingdatasize();
  static const int kWorkingDataSizeFieldNumber = 4;
  inline ::google::protobuf::int64 workingdatasize() const;
  inline void set_workingdatasize(::google::protobuf::int64 value);

  // repeated .messages.TaskResult.OutputFile outputFile = 5;
  inline int outputfile_size() const;
  inline void clear_outputfile();
  static const int kOutputFileFieldNumber = 5;
  inline const ::messages::TaskResult_OutputFile& outputfile(int index) const;
  inline ::messages::TaskResult_OutputFile* mutable_outputfile(int index);
  inline ::messages::TaskResult_OutputFile* add_outputfile();
  inline const ::google::protobuf::RepeatedPtrField< ::messages::TaskResult_OutputFile >&
      outputfile() const;
  inline ::google::protobuf::RepeatedPtrField< ::messages::TaskResult_OutputFile >*
      mutable_outputfile();

  // @@protoc_insertion_point(class_scope:messages.TaskResult)
 private:
  inline void set_has_exitcode();
  inline void clear_has_exitcode();
  inline void set_has_taskduration();
  inline void clear_has_taskduration();
  inline void set_has_workingdatasize();
  inline void clear_has_workingdatasize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 taskduration_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > commandduration_;
  ::google::protobuf::int64 workingdatasize_;
  ::google::protobuf::RepeatedPtrField< ::messages::TaskResult_OutputFile > outputfile_;
  ::google::protobuf::int32 exitcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TaskResult* default_instance_;
};
// ===================================================================


// ===================================================================

// CommonFile

// required string name = 1;
inline bool CommonFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonFile::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CommonFile::name() const {
  return *name_;
}
inline void CommonFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CommonFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CommonFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CommonFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonFile::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 chunk = 2;
inline bool CommonFile::has_chunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonFile::set_has_chunk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonFile::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonFile::clear_chunk() {
  chunk_ = 0;
  clear_has_chunk();
}
inline ::google::protobuf::int32 CommonFile::chunk() const {
  return chunk_;
}
inline void CommonFile::set_chunk(::google::protobuf::int32 value) {
  set_has_chunk();
  chunk_ = value;
}

// required bool last = 3;
inline bool CommonFile::has_last() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonFile::set_has_last() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonFile::clear_has_last() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonFile::clear_last() {
  last_ = false;
  clear_has_last();
}
inline bool CommonFile::last() const {
  return last_;
}
inline void CommonFile::set_last(bool value) {
  set_has_last();
  last_ = value;
}

// required bytes data = 4;
inline bool CommonFile::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonFile::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonFile::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonFile::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CommonFile::data() const {
  return *data_;
}
inline void CommonFile::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CommonFile::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CommonFile::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonFile::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CommonFile::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonFile::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Task_InputFile

// required string name = 1;
inline bool Task_InputFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task_InputFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task_InputFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task_InputFile::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task_InputFile::name() const {
  return *name_;
}
inline void Task_InputFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task_InputFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task_InputFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_InputFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Task_InputFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task_InputFile::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .messages.Task.InputFile.Scope scope = 2;
inline bool Task_InputFile::has_scope() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task_InputFile::set_has_scope() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task_InputFile::clear_has_scope() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task_InputFile::clear_scope() {
  scope_ = 1;
  clear_has_scope();
}
inline ::messages::Task_InputFile_Scope Task_InputFile::scope() const {
  return static_cast< ::messages::Task_InputFile_Scope >(scope_);
}
inline void Task_InputFile::set_scope(::messages::Task_InputFile_Scope value) {
  assert(::messages::Task_InputFile_Scope_IsValid(value));
  set_has_scope();
  scope_ = value;
}

// optional bytes data = 3;
inline bool Task_InputFile::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task_InputFile::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task_InputFile::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task_InputFile::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Task_InputFile::data() const {
  return *data_;
}
inline void Task_InputFile::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Task_InputFile::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Task_InputFile::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_InputFile::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Task_InputFile::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task_InputFile::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .messages.Task.InputFile.PreProcessor preProcessor = 4;
inline bool Task_InputFile::has_preprocessor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task_InputFile::set_has_preprocessor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task_InputFile::clear_has_preprocessor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task_InputFile::clear_preprocessor() {
  preprocessor_ = 1;
  clear_has_preprocessor();
}
inline ::messages::Task_InputFile_PreProcessor Task_InputFile::preprocessor() const {
  return static_cast< ::messages::Task_InputFile_PreProcessor >(preprocessor_);
}
inline void Task_InputFile::set_preprocessor(::messages::Task_InputFile_PreProcessor value) {
  assert(::messages::Task_InputFile_PreProcessor_IsValid(value));
  set_has_preprocessor();
  preprocessor_ = value;
}

// -------------------------------------------------------------------

// Task_OutputFile

// required string name = 1;
inline bool Task_OutputFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task_OutputFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task_OutputFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task_OutputFile::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task_OutputFile::name() const {
  return *name_;
}
inline void Task_OutputFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task_OutputFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task_OutputFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_OutputFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Task_OutputFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task_OutputFile::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .messages.Task.OutputFile.PostProcessor postProcessor = 2;
inline bool Task_OutputFile::has_postprocessor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task_OutputFile::set_has_postprocessor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task_OutputFile::clear_has_postprocessor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task_OutputFile::clear_postprocessor() {
  postprocessor_ = 1;
  clear_has_postprocessor();
}
inline ::messages::Task_OutputFile_PostProcessor Task_OutputFile::postprocessor() const {
  return static_cast< ::messages::Task_OutputFile_PostProcessor >(postprocessor_);
}
inline void Task_OutputFile::set_postprocessor(::messages::Task_OutputFile_PostProcessor value) {
  assert(::messages::Task_OutputFile_PostProcessor_IsValid(value));
  set_has_postprocessor();
  postprocessor_ = value;
}

// -------------------------------------------------------------------

// Task_Variable

// required string name = 1;
inline bool Task_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task_Variable::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task_Variable::name() const {
  return *name_;
}
inline void Task_Variable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task_Variable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_Variable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Task_Variable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task_Variable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Task_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task_Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Task_Variable::value() const {
  return *value_;
}
inline void Task_Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Task_Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Task_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Task_Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task_Variable::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Task_Environment

// repeated .messages.Task.Variable variable = 1;
inline int Task_Environment::variable_size() const {
  return variable_.size();
}
inline void Task_Environment::clear_variable() {
  variable_.Clear();
}
inline const ::messages::Task_Variable& Task_Environment::variable(int index) const {
  return variable_.Get(index);
}
inline ::messages::Task_Variable* Task_Environment::mutable_variable(int index) {
  return variable_.Mutable(index);
}
inline ::messages::Task_Variable* Task_Environment::add_variable() {
  return variable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_Variable >&
Task_Environment::variable() const {
  return variable_;
}
inline ::google::protobuf::RepeatedPtrField< ::messages::Task_Variable >*
Task_Environment::mutable_variable() {
  return &variable_;
}

// -------------------------------------------------------------------

// Task_Command

// required string program = 1;
inline bool Task_Command::has_program() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task_Command::set_has_program() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task_Command::clear_has_program() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task_Command::clear_program() {
  if (program_ != &::google::protobuf::internal::kEmptyString) {
    program_->clear();
  }
  clear_has_program();
}
inline const ::std::string& Task_Command::program() const {
  return *program_;
}
inline void Task_Command::set_program(const ::std::string& value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void Task_Command::set_program(const char* value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void Task_Command::set_program(const char* value, size_t size) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_Command::mutable_program() {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  return program_;
}
inline ::std::string* Task_Command::release_program() {
  clear_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = program_;
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task_Command::set_allocated_program(::std::string* program) {
  if (program_ != &::google::protobuf::internal::kEmptyString) {
    delete program_;
  }
  if (program) {
    set_has_program();
    program_ = program;
  } else {
    clear_has_program();
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string argument = 2;
inline int Task_Command::argument_size() const {
  return argument_.size();
}
inline void Task_Command::clear_argument() {
  argument_.Clear();
}
inline const ::std::string& Task_Command::argument(int index) const {
  return argument_.Get(index);
}
inline ::std::string* Task_Command::mutable_argument(int index) {
  return argument_.Mutable(index);
}
inline void Task_Command::set_argument(int index, const ::std::string& value) {
  argument_.Mutable(index)->assign(value);
}
inline void Task_Command::set_argument(int index, const char* value) {
  argument_.Mutable(index)->assign(value);
}
inline void Task_Command::set_argument(int index, const char* value, size_t size) {
  argument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task_Command::add_argument() {
  return argument_.Add();
}
inline void Task_Command::add_argument(const ::std::string& value) {
  argument_.Add()->assign(value);
}
inline void Task_Command::add_argument(const char* value) {
  argument_.Add()->assign(value);
}
inline void Task_Command::add_argument(const char* value, size_t size) {
  argument_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Task_Command::argument() const {
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Task_Command::mutable_argument() {
  return &argument_;
}

// optional int32 timeout = 3;
inline bool Task_Command::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task_Command::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task_Command::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task_Command::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 Task_Command::timeout() const {
  return timeout_;
}
inline void Task_Command::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// Task

// required int32 jobId = 1;
inline bool Task::has_jobid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_jobid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_jobid() {
  jobid_ = 0;
  clear_has_jobid();
}
inline ::google::protobuf::int32 Task::jobid() const {
  return jobid_;
}
inline void Task::set_jobid(::google::protobuf::int32 value) {
  set_has_jobid();
  jobid_ = value;
}

// required int32 index = 2;
inline bool Task::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Task::index() const {
  return index_;
}
inline void Task::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required .messages.Task.Environment env = 3;
inline bool Task::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_env() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_env() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_env() {
  if (env_ != NULL) env_->::messages::Task_Environment::Clear();
  clear_has_env();
}
inline const ::messages::Task_Environment& Task::env() const {
  return env_ != NULL ? *env_ : *default_instance_->env_;
}
inline ::messages::Task_Environment* Task::mutable_env() {
  set_has_env();
  if (env_ == NULL) env_ = new ::messages::Task_Environment;
  return env_;
}
inline ::messages::Task_Environment* Task::release_env() {
  clear_has_env();
  ::messages::Task_Environment* temp = env_;
  env_ = NULL;
  return temp;
}
inline void Task::set_allocated_env(::messages::Task_Environment* env) {
  delete env_;
  env_ = env;
  if (env) {
    set_has_env();
  } else {
    clear_has_env();
  }
}

// required string cmdId = 4;
inline bool Task::has_cmdid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_cmdid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_cmdid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_cmdid() {
  if (cmdid_ != &::google::protobuf::internal::kEmptyString) {
    cmdid_->clear();
  }
  clear_has_cmdid();
}
inline const ::std::string& Task::cmdid() const {
  return *cmdid_;
}
inline void Task::set_cmdid(const ::std::string& value) {
  set_has_cmdid();
  if (cmdid_ == &::google::protobuf::internal::kEmptyString) {
    cmdid_ = new ::std::string;
  }
  cmdid_->assign(value);
}
inline void Task::set_cmdid(const char* value) {
  set_has_cmdid();
  if (cmdid_ == &::google::protobuf::internal::kEmptyString) {
    cmdid_ = new ::std::string;
  }
  cmdid_->assign(value);
}
inline void Task::set_cmdid(const char* value, size_t size) {
  set_has_cmdid();
  if (cmdid_ == &::google::protobuf::internal::kEmptyString) {
    cmdid_ = new ::std::string;
  }
  cmdid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_cmdid() {
  set_has_cmdid();
  if (cmdid_ == &::google::protobuf::internal::kEmptyString) {
    cmdid_ = new ::std::string;
  }
  return cmdid_;
}
inline ::std::string* Task::release_cmdid() {
  clear_has_cmdid();
  if (cmdid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmdid_;
    cmdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task::set_allocated_cmdid(::std::string* cmdid) {
  if (cmdid_ != &::google::protobuf::internal::kEmptyString) {
    delete cmdid_;
  }
  if (cmdid) {
    set_has_cmdid();
    cmdid_ = cmdid;
  } else {
    clear_has_cmdid();
    cmdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .messages.Task.Command command = 5;
inline int Task::command_size() const {
  return command_.size();
}
inline void Task::clear_command() {
  command_.Clear();
}
inline const ::messages::Task_Command& Task::command(int index) const {
  return command_.Get(index);
}
inline ::messages::Task_Command* Task::mutable_command(int index) {
  return command_.Mutable(index);
}
inline ::messages::Task_Command* Task::add_command() {
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_Command >&
Task::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::messages::Task_Command >*
Task::mutable_command() {
  return &command_;
}

// repeated .messages.Task.InputFile inputFile = 6;
inline int Task::inputfile_size() const {
  return inputfile_.size();
}
inline void Task::clear_inputfile() {
  inputfile_.Clear();
}
inline const ::messages::Task_InputFile& Task::inputfile(int index) const {
  return inputfile_.Get(index);
}
inline ::messages::Task_InputFile* Task::mutable_inputfile(int index) {
  return inputfile_.Mutable(index);
}
inline ::messages::Task_InputFile* Task::add_inputfile() {
  return inputfile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_InputFile >&
Task::inputfile() const {
  return inputfile_;
}
inline ::google::protobuf::RepeatedPtrField< ::messages::Task_InputFile >*
Task::mutable_inputfile() {
  return &inputfile_;
}

// repeated .messages.Task.OutputFile outputFile = 7;
inline int Task::outputfile_size() const {
  return outputfile_.size();
}
inline void Task::clear_outputfile() {
  outputfile_.Clear();
}
inline const ::messages::Task_OutputFile& Task::outputfile(int index) const {
  return outputfile_.Get(index);
}
inline ::messages::Task_OutputFile* Task::mutable_outputfile(int index) {
  return outputfile_.Mutable(index);
}
inline ::messages::Task_OutputFile* Task::add_outputfile() {
  return outputfile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::messages::Task_OutputFile >&
Task::outputfile() const {
  return outputfile_;
}
inline ::google::protobuf::RepeatedPtrField< ::messages::Task_OutputFile >*
Task::mutable_outputfile() {
  return &outputfile_;
}

// required bool initJob = 8;
inline bool Task::has_initjob() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Task::set_has_initjob() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Task::clear_has_initjob() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Task::clear_initjob() {
  initjob_ = false;
  clear_has_initjob();
}
inline bool Task::initjob() const {
  return initjob_;
}
inline void Task::set_initjob(bool value) {
  set_has_initjob();
  initjob_ = value;
}

// repeated int32 completedJobId = 9;
inline int Task::completedjobid_size() const {
  return completedjobid_.size();
}
inline void Task::clear_completedjobid() {
  completedjobid_.Clear();
}
inline ::google::protobuf::int32 Task::completedjobid(int index) const {
  return completedjobid_.Get(index);
}
inline void Task::set_completedjobid(int index, ::google::protobuf::int32 value) {
  completedjobid_.Set(index, value);
}
inline void Task::add_completedjobid(::google::protobuf::int32 value) {
  completedjobid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Task::completedjobid() const {
  return completedjobid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Task::mutable_completedjobid() {
  return &completedjobid_;
}

// -------------------------------------------------------------------

// TaskResult_OutputFile

// required string name = 1;
inline bool TaskResult_OutputFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskResult_OutputFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskResult_OutputFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskResult_OutputFile::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskResult_OutputFile::name() const {
  return *name_;
}
inline void TaskResult_OutputFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskResult_OutputFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskResult_OutputFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskResult_OutputFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskResult_OutputFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskResult_OutputFile::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 2;
inline bool TaskResult_OutputFile::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskResult_OutputFile::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskResult_OutputFile::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskResult_OutputFile::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskResult_OutputFile::data() const {
  return *data_;
}
inline void TaskResult_OutputFile::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskResult_OutputFile::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskResult_OutputFile::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskResult_OutputFile::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskResult_OutputFile::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskResult_OutputFile::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskResult

// required int32 exitCode = 1;
inline bool TaskResult::has_exitcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskResult::set_has_exitcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskResult::clear_has_exitcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskResult::clear_exitcode() {
  exitcode_ = 0;
  clear_has_exitcode();
}
inline ::google::protobuf::int32 TaskResult::exitcode() const {
  return exitcode_;
}
inline void TaskResult::set_exitcode(::google::protobuf::int32 value) {
  set_has_exitcode();
  exitcode_ = value;
}

// required int64 taskDuration = 2;
inline bool TaskResult::has_taskduration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskResult::set_has_taskduration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskResult::clear_has_taskduration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskResult::clear_taskduration() {
  taskduration_ = GOOGLE_LONGLONG(0);
  clear_has_taskduration();
}
inline ::google::protobuf::int64 TaskResult::taskduration() const {
  return taskduration_;
}
inline void TaskResult::set_taskduration(::google::protobuf::int64 value) {
  set_has_taskduration();
  taskduration_ = value;
}

// repeated int64 commandDuration = 3;
inline int TaskResult::commandduration_size() const {
  return commandduration_.size();
}
inline void TaskResult::clear_commandduration() {
  commandduration_.Clear();
}
inline ::google::protobuf::int64 TaskResult::commandduration(int index) const {
  return commandduration_.Get(index);
}
inline void TaskResult::set_commandduration(int index, ::google::protobuf::int64 value) {
  commandduration_.Set(index, value);
}
inline void TaskResult::add_commandduration(::google::protobuf::int64 value) {
  commandduration_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TaskResult::commandduration() const {
  return commandduration_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TaskResult::mutable_commandduration() {
  return &commandduration_;
}

// required int64 workingDataSize = 4;
inline bool TaskResult::has_workingdatasize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskResult::set_has_workingdatasize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskResult::clear_has_workingdatasize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskResult::clear_workingdatasize() {
  workingdatasize_ = GOOGLE_LONGLONG(0);
  clear_has_workingdatasize();
}
inline ::google::protobuf::int64 TaskResult::workingdatasize() const {
  return workingdatasize_;
}
inline void TaskResult::set_workingdatasize(::google::protobuf::int64 value) {
  set_has_workingdatasize();
  workingdatasize_ = value;
}

// repeated .messages.TaskResult.OutputFile outputFile = 5;
inline int TaskResult::outputfile_size() const {
  return outputfile_.size();
}
inline void TaskResult::clear_outputfile() {
  outputfile_.Clear();
}
inline const ::messages::TaskResult_OutputFile& TaskResult::outputfile(int index) const {
  return outputfile_.Get(index);
}
inline ::messages::TaskResult_OutputFile* TaskResult::mutable_outputfile(int index) {
  return outputfile_.Mutable(index);
}
inline ::messages::TaskResult_OutputFile* TaskResult::add_outputfile() {
  return outputfile_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::messages::TaskResult_OutputFile >&
TaskResult::outputfile() const {
  return outputfile_;
}
inline ::google::protobuf::RepeatedPtrField< ::messages::TaskResult_OutputFile >*
TaskResult::mutable_outputfile() {
  return &outputfile_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::messages::Task_InputFile_PreProcessor>() {
  return ::messages::Task_InputFile_PreProcessor_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::messages::Task_InputFile_Scope>() {
  return ::messages::Task_InputFile_Scope_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::messages::Task_OutputFile_PostProcessor>() {
  return ::messages::Task_OutputFile_PostProcessor_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
